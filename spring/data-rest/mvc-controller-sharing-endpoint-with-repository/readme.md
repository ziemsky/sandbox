# Summary
This project demonstrates how to plug custom Spring MVC controller so that it listens on the same endpoint as the one
exposed by Spring Data REST (SDR) for given repository where calls are dispatched to the custom controller or to SDR
depending on their [`Content-Type`][content-type header].

Additionally, it shows various ways of converting request body using both custom and Spring-provided converters. As a
bonus it also demonstrates handling of files uploaded via web browser. 

Uses [Spring Boot], [Spring Data REST], [Spring MVC].

# What
Suppose your SDR application has a registry of users; you model them with class `User` and define [Spring Data JPA]
repository `UserRepository` which SDR exposes under endpoint `/users`.

Out of the box, SDR supports handling `POST` requests with `application/json` content type to create database records.

You want to keep this functionality but also want to be able to create users defined in a CSV file.

It would be nice to be able to upload it to the same `/users` endpoint, rather than having to pollute your
otherwise clean API with something like `/users/csv`.

Format of the response generated to the POST request should be consistent with the one generated by SDR. 

# How
## Making custom controller listen on endpoint shared with SDR 
The key aspect of defining custom controller that is intended to share an endpoint with SDR is that you need to annotate
it with [`@RepositoryRestController`][sdr custom response handlers] rather than just `@Controller` or `@RestController`;
this way you'll make it mapped within the same space as the SDR endpoint.

In terms of defining `@RequestMapping`'s `path` attribute, its been observed that the best results were achieved by
defining it on method level rather than at class level

See `UserController` for example of the above.

## Request body conversion
The need to make a custom controller handle _some_ of the requests made to a given endpoint while leaving most
of them to be handled by SDR, typically arises because some pre or post processing of the request needs to take place,
one that is too complex for a typical SDR endpoint implementation to handle. In this cases, conversion of the request's
body is an aspect that typically also needs to be addressed.
 
Considering the CSV example mentioned in the summary above, SDR won't know the exact format of your CSV file so you'll
need to plug some custom logic to interpret it and emit objects of type `User`. Your `UserRepository` should be then
asked to persist the object(s) and a response should be generated to inform the caller of the status of this operation.

There are essentially two places in the process of handling a request where you can inject this custom conversion logic:
* Custom or Spring-provided [`HttpMessageConverter`][spring message converters]s allow for converting 'raw' request body
  into a more usable format _before_ the repository's or controller's method gets called so that the repository or  
  controller only has to deal with object it really cares about, not having to bother with facilitating the conversion
  themselves. 
* When using custom MVC controller, you can make it to accept request in its more 'raw' form and delegate conversion
  to your own conversion routine which doesn't need to implement `HttpMessageConverter` interface in such a case.

Using custom `HttpMessageConverter` that takes raw input and emits object of type directly consumed by your
repository allows you to avoid having to implement custom controller. On the other hand, when some more elaborate
processing is needed, use of custom controller may be preferable.

For example of how to register an `HttpMessageConverter` (be it custom or Spring-provided one) see
`ApplicationConfiguration` class and its use of `RepositoryRestConfigurer`. 

# Demo
To run the application, navigate to root directory of the sandbox project (the one containing `.git` directory) and
execute:
```
./gradlew :spring:data-rest:mvc-controller-sharing-endpoint-with-repository:bootRun
```
This will start the application making it accept requests on port 8080.

To run tests execute:

```
./gradlew :spring:data-rest:mvc-controller-sharing-endpoint-with-repository:test
```

## Variants
Each of the variants below are exercised in class `ApplicationTest`.  

## Variant 1: custom HttpMessageConverter + SDR generated endpoint
1. Create custom `HttpMessageConverter` making it read desired input content type and produce object of type consumed by
   your repository.
1. Register it in application configuration.

Illustrated by `MadeUpFormatOneToUserHttpMessageConverter`; it supports a custom content type `made/up-1` and converts
request's body to a single `User` object. It's registered with the application in `ApplicationConfiguration`.

When a request is made with `Content-Type` header set to `made/up-1`, SDR looks up message converters supporting this
format, asks it to translate the raw request body into an object(s) of type expected by your repository (`User`) and
then passes the result straight to the (dynamically implemented) [Spring Data JPA] repository (`UserRepository`).

Tested by `ApplicationTest.createsRecordsThroughSpringDataRest_fromCustomMediaTypeInputOne`.

## Variant 2: default HttpMessageConverter + custom MVC controller
1. Choose one of the [Spring-provided `HttpMessageConverter`s][spring message converters]
1. Register it in application configuration.
1. Create custom MVC controller and make it accept the converter's output. It'll need to arrange for the input to be
   converted to the type accepted by the repository (likely by delegating to another custom converter) and then pass the
   result to the repository itself. It'll also need
   to generate response in a format consistent with that emitted by SDR.
   
Tested by `ApplicationTest.createsRecordsThroughSpringDataRestController_fromCustomMediaTypeInputTwo`.   

## Variant 3: custom HttpMessageConverter + custom converter + custom MVC controller
1. Create custom `HttpMessageConverter` making it read desired input content type and produce 'intermediate' object of
   type later consumed by your controller and another custom converter.
1. Register it in application configuration.
1. Create custom converter (not necessarily `HttpMessageConverter`) making it read the 'intermediate' content type
   consumed by the controller and produce object of type consumed by your repository.   
1. Create custom MVC controller and make it accept the first converter's output and pass it to the secondary converter,
   take output of the latter and pass it to the repository. Also make it generate response in a format consistent with
   that emitted by SDR.
   
Tested by `ApplicationTest.createsRecordsThroughCustomController_fromCsvMediaTypeInput`   
   
## Variant 4: custom MVC controller + custom converter 
1. Create custom converter (not necessarily `HttpMessageConverter`) making it read content type consumed by the
   controller and produce object of type consumed by your repository.
1. Create custom MVC controller and make it pass request's body to custom converter, take output of the latter and pass
   it to the repository. Also make it generate response in a format consistent with that emitted by SDR.
   
This variant deals with handling files uploaded via web browser; tested by
`ApplicationTest.createsRecordsThroughCustomController_fromUploadedCsvFile`.      


 
# Troubleshooting
When you see errors 415 'Unsupporter Media Type' the first things to check are:
* When using custom controller, check whether you have defined `@RequestMapping` with `path` attribute on method level
  rather than class level.
* Whether you have registered correct `HttpMessageConverter`, i.e. one that consumes correct content type and emits
  objects of types expected either by your controller or repository. See
  `ApplicationConfiguration.repositoryRestConfigurer` for example of how to log message coverters registered in your
  application.
  
If you're seeing error 404 'Not Found' when using custom controller, it _could_ be because you forgot to annotate your
controller class with `@RepositoryRestController`.
 

[spring boot]:                     https://projects.spring.io/spring-boot/
[spring data rest]:                http://projects.spring.io/spring-data-rest/
[spring mvc]:                      http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html
[spring message converters]:       http://docs.spring.io/spring/docs/current/spring-framework-reference/html/mvc.html#mvc-ann-requestbody
[spring data jpa]:                 http://projects.spring.io/spring-data-jpa/
[sdr custom response handlers]:    http://docs.spring.io/spring-data/rest/docs/current/reference/html/#customizing-sdr.adding-sdr-to-spring-mvc-app

[content-type header]:             https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Type